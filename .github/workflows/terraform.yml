name: Terraform Infrastructure
on:
  workflow_dispatch:
  workflow_call:
    inputs:
      terraform-action:
        description: 'Terraform action to perform (plan/apply)'
        required: false
        default: 'apply'
        type: string
    outputs:
      cluster_name:
        description: "EKS cluster name"
        value: ${{ jobs.terraform.outputs.cluster_name }}
      namespace:
        description: "Kubernetes namespace for the application"
        value: ${{ jobs.terraform.outputs.app_namespace }}
      terraform-result:
        description: "Terraform execution result"
        value: ${{ jobs.terraform.outputs.result }}

jobs:
  terraform:
    name: Terraform Deployment
    runs-on: ubuntu-latest
    environment: production
    outputs:
      result: ${{ steps.terraform-action.outcome }}
      cluster_name: ${{ steps.terraform-outputs.outputs.cluster_name }}
      namespace: ${{ steps.terraform-outputs.outputs.app_namespace }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v5
        
      - name: Login to AWS
        uses: aws-actions/configure-aws-credentials@v4.3.1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: 1.5.7
          
      - name: Terraform Init
        run: terraform init
        working-directory: ./Terraform
        
      - name: Terraform Plan
        run: terraform plan
        working-directory: ./Terraform
        
      - name: Terraform Apply
        id: terraform-action
        if: ${{ inputs.terraform-action == 'apply' || inputs.terraform-action == '' }}
        run: terraform apply -auto-approve
        working-directory: ./Terraform

      - name: Get Terraform outputs
        id: terraform-outputs
        run: |
          CLUSTER_NAME=$(terraform output -raw cluster_name)
          APP_NAMESPACE=$(terraform output -raw app_namespace)
          MONITORING_NAMESPACE=$(terraform output -raw monitoring_namespace)
          ARGOCD_NAMESPACE=$(terraform output -raw argocd_namespace)
          APP_NAME=$(terraform output -raw app_name)

          echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
          echo "APP_NAMESPACE=$APP_NAMESPACE" >> $GITHUB_ENV
          echo "MONITORING_NAMESPACE=$MONITORING_NAMESPACE" >> $GITHUB_ENV
          echo "ARGOCD_NAMESPACE=$ARGOCD_NAMESPACE" >> $GITHUB_ENV
          echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
          
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "app_namespace=$APP_NAMESPACE" >> $GITHUB_OUTPUT
          echo "monitoring_namespace=$MONITORING_NAMESPACE" >> $GITHUB_OUTPUT
          echo "argocd_namespace=$ARGOCD_NAMESPACE" >> $GITHUB_OUTPUT
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
        working-directory: ./Terraform

      - name: Set GitHub repository variables
        run: |
          CLUSTER_NAME=$(terraform output -raw cluster_name)
          APP_NAMESPACE=$(terraform output -raw app_namespace)
          MONITORING_NAMESPACE=$(terraform output -raw monitoring_namespace)
          ARGOCD_NAMESPACE=$(terraform output -raw argocd_namespace)
          APP_NAME=$(terraform output -raw app_name)

          # Create or update repo variables via GitHub CLI
          gh variable set CLUSTER_NAME --body "$CLUSTER_NAME" --repo $GITHUB_REPOSITORY
          gh variable set APP_NAMESPACE --body "$APP_NAMESPACE" --repo $GITHUB_REPOSITORY
          gh variable set MONITORING_NAMESPACE --body "$MONITORING_NAMESPACE" --repo $GITHUB_REPOSITORY
          gh variable set ARGOCD_NAMESPACE --body "$ARGOCD_NAMESPACE" --repo $GITHUB_REPOSITORY
          gh variable set APP_NAME --body "$APP_NAME" --repo $GITHUB_REPOSITORY
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        working-directory: ./Terraform

      # ---------------------------
      # Install ArgoCD with Helm (using GitHub variables)
      # ---------------------------
      - name: Update kubeconfig
        if: ${{ inputs.terraform-action == 'apply' || inputs.terraform-action == '' }}
        run: aws eks update-kubeconfig --name ${{ vars.CLUSTER_NAME }} --region us-east-1

      - name: Install Helm
        if: ${{ inputs.terraform-action == 'apply' || inputs.terraform-action == '' }}
        uses: azure/setup-helm@v4.2.0
        with:
          version: v3.14.0
          
      - name: Add ArgoCD Helm Repo
        if: ${{ inputs.terraform-action == 'apply' || inputs.terraform-action == '' }}
        run: |
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo update
          
      - name: Install/Upgrade ArgoCD
        if: ${{ inputs.terraform-action == 'apply' || inputs.terraform-action == '' }}
        run: |
          helm upgrade --install argocd argo/argo-cd \
            --namespace ${{ vars.ARGOCD_NAMESPACE }} \
            --create-namespace \
            --set server.service.type=LoadBalancer \
            --wait

      - name: Create Grafana Secret
        if: ${{ inputs.terraform-action == 'apply' || inputs.terraform-action == '' }}
        run: |
          kubectl create namespace ${{ vars.MONITORING_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl create secret generic grafana-admin-secret \
            --from-literal=admin-user=admin \
            --from-literal=admin-password='${{ secrets.GRAFANA_ADMIN_PASSWORD }}' \
            --namespace ${{ vars.MONITORING_NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Monitoring
        if: ${{ inputs.terraform-action == 'apply' || inputs.terraform-action == '' }}
        run: |
          export MONITORING_NAMESPACE=${{ vars.MONITORING_NAMESPACE }}
          export ARGOCD_NAMESPACE=${{ vars.ARGOCD_NAMESPACE }}
          envsubst < ./argocd/monitoring.yml | kubectl apply -f -